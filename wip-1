
#if 0
map :: (a -> b) -> [a]* -> [b]*
	a -> b  ==  Str -> Num  -- a==Str -> b==Num
	[a]* -> [b]*  -- ...

Type(Ty::FUN,
  {.box_pair={
    new Type(Ty::FUN,
      {.box_pair={
        new Type(Ty::UNK, {.name=new std::string("a")}, 0),
        new Type(Ty::UNK, {.name=new std::string("b")}, 0)
      }}, 0
    ),
    new Type(Ty::FUN,
      {.box_pair={
        new Type(Ty::LST,
          {.box_has=
            types1(new Type(Ty::UNK, {.name=new std::string("a")}, 0))
          }, TyFlag::IS_INF
        ),
        new Type(Ty::LST,
          {.box_has=
            types1(new Type(Ty::UNK, {.name=new std::string("b")}, 0))
          }, TyFlag::IS_INF
        )
      }}, 0
    )
  }}, 0
)

Type(Ty::FUN,
  {.box_pair={
    new Type(Ty::LST,
      {.box_has=
        types1(new Type(arg->type().from()))
      }, TyFlag::IS_INF
    ),
    new Type(Ty::LST,
      {.box_has=
        types1(new Type(arg->type().to()))
      }, TyFlag::IS_INF
    )
  }}, 0
)
---


unk_make_lookup :: with_unk -> known -> [(name, type)]


template <with_unk, char name>
struct _extract_type_for_name<with_unk, name> {
  Type the(Val* arg) {
    return ...;
  }
};
#endif

#include "sel/types.hpp"
#include "sel/engine.hpp"
using namespace sel;

template <char c> struct unk { inline static Type make() {
  return Type(Ty::UNK, {.name=new std::string(1, c)}, 0);
} };
struct num { inline static Type make() {
  return Type(Ty::NUM, {0}, 0);
} };
/*template <bool>*/ struct str { inline static Type make() {
  return Type(Ty::STR, {0}, TyFlag::IS_FIN);
} };
template <typename has> struct lst { inline static Type make() {
  return Type(Ty::LST, {.box_has=types1(new Type(has::make()))}, TyFlag::IS_FIN);
} };
template <typename from, typename to> struct fun { inline static Type make() {
  return Type(Ty::FUN, {.box_pair={new Type(from::make()), new Type(to::make())}}, 0);
} };

template <char c, typename in>
struct _find_unknown {
  inline static Type find(Type ty) { } //{ return Type(Ty::UNK, {.name=new std::string(1, c)}, 0); }
  constexpr static bool matches = false;
};

template <char c>
struct _find_unknown<c, unk<c>> {
  inline static Type find(Type ty) { return ty; }
  constexpr static bool matches = true;
};

template <char c, typename has>
struct _find_unknown<c, lst<has>> {
  inline static Type find(Type ty) {
    return _find_unknown<c, has>::find(ty.has()[0]);
  }
  constexpr static bool matches = _find_unknown<c, has>::matches;
};


template <char c, typename from, typename to>
struct _find_unknown<c, fun<from, to>> {
  template <bool is_in_from> inline static Type _get(Type ty) { return ty.from(); }
  template <>                inline static Type _get<false>(Type ty) { return ty.to(); }
  inline static Type find(Type ty) {
    return std::conditional<
        _find_unknown<c, from>::matches,
        _find_unknown<c, from>,
        _find_unknown<c, to>
      >::find(_get<_find_unknown<c, from>::matches>(ty));
  }
  constexpr static bool matches
    =  _find_unknown<c, from>::matches
    || _find_unknown<c, to>::matches;
};

template <typename from, typename to>
struct _now_known;

template <char a, typename has_unknowns>
struct _now_known<has_unknowns, lst<unk<a>>> { // X<a> -> [a]
  inline static Type make(Val* arg) {
    return Type(Ty::LST,
      {.box_has=
        types1(new Type(
          // eg. if X<a> is (Num -> a), this will be `arg->type().to()`
          _find_unknown<a, has_unknowns>::find(arg->type())
        ))
      }, 0
    );
  }
};

template <char a, typename has_unknowns>
struct _now_known<has_unknowns, lst<fun<num, unk<a>>>> { // X<a> -> [Num -> a]
  inline static Type make(Val* arg) {
    return Type(Ty::LST,
      {.box_has=
        types1(new Type(
          // fun<num, v-- this --v>::make()
          _find_unknown<a, has_unknowns>::find(arg->type())
        ))
      }, 0
    );
  }
};
