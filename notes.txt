
pour une chaîne de charactère infinie (issue de ..)
 - si on sait qu'elle est plus utilisée ailleur, ok (d'ailleur même si finie pas besoin de cache)
 - si elle peut être utilisée ailleur, besoin de savoir si ce calcule peut finire

par exemple : couper et retourner la première partie d'une
chaîne de charactère (jusqu'a un délimiteur quelconque)
; dans ce ca le calcule peut finire, et la possibilitée
que la même chaîne soit ré-utilisée dans un autre
calcule existe, donc il est nécessaire de cache autant
que possible.

en revanche, si on sait que le calcule ne peut pas finir,
on est bon pour avancer l'état interne de la chaîne sans
construire de cache.

---

le patterne c'est : es-ce que une structure infinie
(s'applique aux chaînes de charactères et list
récursivement) est envoyer dans un calcule qui peut finire
ET est envoyer dans un autre calcule plus tard.

d'où les besoin de savoir :
 - si une structure est infinie [ie. quoi exactement ?]
 - si un calcule sur une structure infinie peut finire
 - dans quel calcule une structure est envoyée, et dans quel ordre

---

whether a value is unbounded is reflected in its type by
a *, as such the following:
 - Str*
 - [any]*
 - list of unbounded type or couple with either unbounded

a function's signature conveis this information, for example:
 - repeat :: a -> [a]*
 - accumulate :: () -> [Str]* -- TODO: figure out how to translate recurse

some functions may be able to consume an unbounded value
and still produce a bounded value:
 - take :: Num -> [a]* -> [a] -- (so take 5 is such a function)

some other functions may still be able to operate,
producing an unbounded value:
 - join :: Str -> [Str]* -> Str*

otherwise, a function that does not explicitely specify
its behavior with unbounded argument is assumed to hang
on such input (forced crash with diagnostic)
